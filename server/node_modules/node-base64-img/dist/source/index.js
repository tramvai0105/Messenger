"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mime_1 = require("./mime");
const path_1 = __importDefault(require("path"));
const file_1 = require("./file");
const base64_1 = require("./base64");
const node_fetch_1 = __importDefault(require("node-fetch"));
//The initial async convert function
const base64Img = async (base64String, destPath, fileName, options) => {
    try {
        let mimeType;
        if (!(options === null || options === void 0 ? void 0 : options.type)) {
            mimeType = mime_1.findMimeType(base64String);
        }
        else {
            mimeType = options.type;
            mime_1.validateMimeType(mimeType);
        }
        const data = base64String.replace(/^data:image\/\w+;base64,/, '');
        base64_1.checkIfValidBase64(data);
        const filePath = path_1.default.join(destPath);
        const fullPath = path_1.default.join(filePath, fileName + `.${mimeType}`);
        if (file_1.checkValidDestination(filePath)) {
            await file_1.writeToMemory(fullPath, data);
        }
        const result = {
            path: fullPath,
            mimeType: mimeType
        };
        return result;
    }
    catch (error) {
        throw error;
    }
};
base64Img.toBase64 = async (urlOrPath) => {
    if (base64_1.checkIfValidUrl(urlOrPath)) {
        const response = await node_fetch_1.default(urlOrPath);
        const responseBuffer = await response.buffer();
        return base64_1.bufferToString(responseBuffer);
    }
    else {
        file_1.isImage(urlOrPath);
        return await file_1.readFileAndConvert(urlOrPath);
    }
};
exports.default = base64Img;
// For CommonJS default export support
module.exports = base64Img;
module.exports.default = base64Img;
