"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readFileAndConvert = exports.isImage = exports.writeToMemory = exports.checkValidDestination = void 0;
const fs_1 = __importDefault(require("fs"));
const util_1 = require("util");
const errors_1 = require("./errors");
const messages_1 = require("./messages");
const path_1 = __importDefault(require("path"));
const base64_1 = require("./base64");
const writeFile = util_1.promisify(fs_1.default.writeFile);
const readFile = util_1.promisify(fs_1.default.readFile);
function checkValidDestination(destination) {
    if (fs_1.default.existsSync(destination)) {
        return true;
    }
    throw new errors_1.filePathError(`${messages_1.ERROR_MESSAGES.FILE_PATH_DOES_NOT_EXIST}${destination}`);
}
exports.checkValidDestination = checkValidDestination;
async function writeToMemory(filePath, data) {
    await writeFile(filePath, data, { encoding: 'base64' });
}
exports.writeToMemory = writeToMemory;
;
function isImage(path) {
    checkValidDestination(path);
    if (validTypeImage(path)) {
        if (fs_1.default.statSync(path).isFile()) {
            return true;
        }
        throw new errors_1.filePathError(`${messages_1.ERROR_MESSAGES.FILE_PATH_DOES_NOT_EXIST}${path}`);
    }
    throw new errors_1.mimeError(messages_1.ERROR_MESSAGES.UNSUPPORTED_MIME_TYPE);
}
exports.isImage = isImage;
function validTypeImage(image) {
    return /(?<=\S+)\.(jpg|png|jpeg|gif)/gi.test(image);
}
async function readFileAndConvert(fileName) {
    return base64_1.bufferToString(await readFile(path_1.default.resolve(fileName)));
}
exports.readFileAndConvert = readFileAndConvert;
